"""
Generate wrappers to dispatch BLAS/LAPACK calls to the properly prefixed/
suffixed symbols.

For example, MacOS 13.3+ has a new, LAPACK 3.9-compatible, high performance
BLAS/LAPACK implementation. These functions are provided side-by-side with
the old implementation, and the symbols are distinguished by appending the
literal suffix "$NEWLAPACK".

To point our BLAS/LAPACK calls to these symbols, we need to create wrappers
which call them appropriately. We do this as simple C function declarations
that make use of the preprocessor macros defined in npy_cblas.h.

We already have all the required signature information in
    scipy/linalg/cython_{blas,lapack}_signatures.txt
which is generated by
    scipy/linalg/_cython_signature_generator.py

We automatically create the declarations based on these signatures, with a
few special cases. First, all complex-valued functions are skipped (empty
source files) because they require more complicated wrapper logic. The
wrappers for these functions are hard-coded in wrap_g77_abi.c and
wrap_dummy_g77_abi.c. Second, certain functions are missing from the
new Accelerate implementation and/or have unusual symbols that require
special handling in this script.
"""
import argparse
import os

CURR_DIR = os.path.dirname(os.path.abspath(__file__))
LINALG_DIR = os.path.abspath(os.path.join(CURR_DIR, "..", "linalg"))

# Used to convert from types in signature files to C types
c_types = {'int': 'CBLAS_INT',
           'c': 'npy_complex64',
           'd': 'double',
           's': 'float',
           'z': 'npy_complex128',
           'char': 'char',
           'bint': 'CBLAS_INT',
           'void': 'void',
           'cselect1': '_cselect1',
           'cselect2': '_cselect2',
           'dselect2': '_dselect2',
           'dselect3': '_dselect3',
           'sselect2': '_sselect2',
           'sselect3': '_sselect3',
           'zselect1': '_zselect1',
           'zselect2': '_zselect2'}


def read_signatures(lines):
    """
    Read BLAS/LAPACK signatures and split into name, return type, C parameter
    list (e.g. `int* a, bint* b`), and argument names (e.g. `a, b`).
    """
    sigs = []
    for line in lines:
        line = line.strip()
        if not line or line.startswith('#'):
            continue
        line = line[:-1].split('(')
        args = line[1]
        name_and_type = line[0].split(' ')
        ret_type = name_and_type[0]
        name = name_and_type[1]
        ret_type = c_types[ret_type]
        argtypes, argnames = zip(*[arg.split(' *') for arg in args.split(', ')])
        argtypes = [c_types[t] for t in argtypes]
        param_list = ', '.join(f'{t} *{n}' for t, n in zip(argtypes, argnames))
        argnames = ', '.join(argnames)
        sigs.append({
            'name': name,
            'return_type': ret_type,
            'param_list': param_list,
            'argnames': argnames
        })
    return sigs


# BLAS/LAPACK functions with complex return values (skipped)
wrapped_funcs = ['cdotc', 'cdotu', 'zdotc', 'zdotu', 'cladiv', 'zladiv']


def create_wrapper(name, return_type, param_list, argnames, accelerate):
    """
    Create the main body of the wrapper file.

    Wrapper has symbol `F_FUNC(name,NAME)` and wraps the BLAS/LAPACK function
    `fort_macro(fort_name)` (by default: `BLAS_FUNC(name)`).
    """
    fort_macro = 'BLAS_FUNC'
    fort_name = name
    if name in wrapped_funcs:
        return ""
    # Use old Accelerate symbols if missing from new API
    elif accelerate:
        # Old symbol same as F_FUNC(name,NAME) so no wrapper needed
        if name in ['dcabs1', 'lsame']:
            return ""
        elif name == 'xerbla_array':
            fort_macro = ''
            fort_name += '__'
    return f"""
{return_type} {fort_macro}({fort_name})({param_list});
{return_type} F_FUNC({name},{name.upper()})({param_list}){{
    return {fort_macro}({fort_name})({argnames});
}}
"""


c_preamble = """#include "fortran_defs.h"
#include "npy_cblas.h"
"""

lapack_decls = """
typedef int (*_cselect1)(npy_complex64*);
typedef int (*_cselect2)(npy_complex64*, npy_complex64*);
typedef int (*_dselect2)(double*, double*);
typedef int (*_dselect3)(double*, double*, double*);
typedef int (*_sselect2)(float*, float*);
typedef int (*_sselect3)(float*, float*, float*);
typedef int (*_zselect1)(npy_complex128*);
typedef int (*_zselect2)(npy_complex128*, npy_complex128*);
"""

cpp_guard_begin = """
#ifdef __cplusplus
extern "C" {
#endif
"""

cpp_guard_end = """
#ifdef __cplusplus
}
#endif
"""

comments = ["This file was generated by _generate_blas_wrapper.py.\n",
            "Do not edit this file directly.\n"]
ccomment = ''.join(['/* ' + line.rstrip() + ' */\n'
                    for line in comments]) + '\n'


def generate_c_files(sigs, lib_name, accelerate, outdir):
    preamble = [c_preamble]
    if lib_name == 'LAPACK':
        preamble.append(lapack_decls)
    preamble.append(cpp_guard_begin)
    for sig in sigs:
        with open(os.path.join(outdir, f'{sig["name"]}.c'), 'w') as f:
            f.writelines("".join(preamble + [
                create_wrapper(**sig, accelerate=accelerate), cpp_guard_end]))


def make_all(outdir,
             blas_signature_file=os.path.join(
                 LINALG_DIR, "cython_blas_signatures.txt"),
             lapack_signature_file=os.path.join(
                 LINALG_DIR, "cython_lapack_signatures.txt"),
             accelerate=False):
    with open(blas_signature_file) as f:
        blas_sigs = f.readlines()
    blas_sigs = read_signatures(blas_sigs)
    generate_c_files(blas_sigs, 'BLAS', accelerate, outdir)
    with open(lapack_signature_file) as f:
        lapack_sigs = f.readlines()
    lapack_sigs = read_signatures(lapack_sigs)
    generate_c_files(lapack_sigs, 'LAPACK', accelerate, outdir)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("-o", "--outdir", type=str,
                        help="Path to the output directory")
    parser.add_argument("-a", "--accelerate", action="store_true",
                        help="Whether to use new Accelerate (macOS 13.3+)")
    args = parser.parse_args()

    if not args.outdir:
        outdir_abs = os.path.abspath(os.path.dirname(__file__))
    else:
        outdir_abs = os.path.join(os.getcwd(), args.outdir)

    make_all(outdir_abs, accelerate=args.accelerate)
